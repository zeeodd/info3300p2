<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Zipf's Law in Music</title>
        <link href="https://fonts.googleapis.com/css?family=Lato:300,400" rel="stylesheet">
        <style>
            html { font-family: "Lato"; font-weight: 300; }
            .artist-cell { margin-top: 10px; }
            .artist-img { width: 100%; opacity: 1; transition: 0.3s; }
            .artist-label { text-align: center; }
            .section-header { text-align: center; font-size: 24px; margin-bottom: 20px; font-family: "Lato"; font-weight: 400; }
            .linear-scale, .log-scale { opacity: 0; }
            .active { opacity: 1; }
            .row { margin-bottom: 50px; }
            .coldplay-overlay { background-color: red; }
            .kanye-overlay { background-color: orange; }
            .keith-overlay { background-color: green; }
            .taylor-overlay { background-color: pink; }
            .rihanna-overlay { background-color: blue; }
            .linkin-overlay { background-color: black; }
            .overlay { transition: 0.3s; cursor: pointer; }
            .artist-img-active { opacity: 0.5; }
            .artist-list { text-align: center; list-style: none; }
        </style>
        <!-- Latest compiled and minified CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
        <script src="https://d3js.org/d3.v4.min.js"></script>
    </head>
    <body>
        <main class='container'>
            <div class='row'>
                <div class='col-xs-12 section-header'>
                    Zipf's Law Proof of Concept
                </div>
                <div class='text-paragraph col-xs-offset-2 col-xs-8'>
                    <b>Zipf's Law</b> in an empirical mathematical law named after the linguist George Kingsley Zipf who first proposed it in the first half of the 20th century. The law relates a word's <em>frequency</em> of occurence with its <em>rank</em> in its related corpus. In particular, given a large enough sample of words, the frequency of any word is inversely proportional to its rank in the sample's table of frequencies. Thus the most frequently occurring word will occur about twice as often as the second most frequent word, and so on. In the graph below, the <b>bolded black line</b> denotes a Zeta distribution that approximates Zipf's Law.
                </div>
            </div>

            <div class='row'>
                <svg class='col-xs-offset-2 col-xs-8 svg-styles pride-svg' height="400"></svg>
            </div>

            <div class='row'>
                <div class='col-xs-12 section-header'>
                    Applying Zipf's Law to Song Lyrics
                </div>
                <div class='text-paragraph col-xs-offset-2 col-xs-8'>
                    We felt as though this interesting mathematical law could be applied to lyrical data and the same patterns would emerge, so we aggregated lyrical data from six different artists. The artists we chose are additionally from a diverse set of genres to further see if the supposed trends would be contrained to one genre or not. Our artists include:
                    <br/>
                    <br/>
                    <ul class="artist-list">
                      <li> <b><span style="color: red;">Coldplay</span></b> of Alternative Rock</li>
                      <li> <b><span style="color: orange;">Kanye West</span></b> of Hip-Hop </li>
                      <li> <b><span style="color: green;">Keith Urban</span></b> of Country </li>
                      <li> <b>Linkin Park</b> of Rock </li>
                      <li> <b><span style="color: blue;">Rihanna</span></b> of R&B </li>
                      <li> <b><span style="color: pink;">Taylor Swift</span></b> of Pop </li>
                    </ul>
                    <br/>
                    The interface below will allow you to test our hypothesis yourself. Selecting an artist will allow you to view each of their respective lyrics on a <b>frequency</b> by <b>rank</b> chart. The chart's scale can be changed to view a log plot of the data for better comparisons of the curves. The slider below the chart gives you control over the number of words displayed. Finally, we included several words of interest that we discovered while investigating the data. We encourage you to select one of our designated words or hover over any of the other data points to discover your own lyrical relationships!
                </div>
            </div>

            <div class='row'>
                <svg class='svg-styles artist-svg col-xs-8' height="625"></svg>
                <div class='col-xs-4'>
                    Significant Words:
                    <select class='word-selector'>
                        <option value="none">Select Word</option>
                        <option value="love">Love</option>
                        <option value="money">Money</option>
                        <option value="god">God</option>
                        <option value="black">Black</option>
                        <option value="like">Like</option>
                        <option value="never">Never</option>
                        <option value="know">Know</option>
                        <option value="baby">Baby</option>
                        <option value="pain">Pain</option>
                    </select>
                </div>
                <div class='col-xs-4'>
                    Scale:
                    <select class='scale-selector'>
                        <option value="linear">Linear</option>
                        <option value="log">Log</option>
                    </select>
                </div>
                <div class='col-xs-2 artist-cell'>
                    <div class='overlay coldplay-overlay'>
                        <img class='artist-img' id='coldplay' src='images/coldplay.jpg' alt='Coldplay Portrait'>
                    </div>

                    <p class='artist-label'>Coldplay</p>
                </div>
                <div class='col-xs-2 artist-cell'>
                    <div class='overlay kanye-overlay'>
                        <img class='artist-img' id='kanye' src='images/kanye.jpg' alt='Kanye West Portrait'>
                    </div>
                    <p class='artist-label'>Kanye West</p>
                </div>
                <div class='col-xs-2 artist-cell'>
                    <div class='overlay keith-overlay'>
                        <img class='artist-img' id='keith' src='images/keith.jpg' alt='Keith Urban Portrait'>
                    </div>
                    <p class='artist-label'>Keith Urban</p>
                </div>
                <div class='col-xs-2 artist-cell'>
                    <div class='overlay linkin-overlay'>
                        <img class='artist-img' id='linkin' src='images/linkin.jpg' alt='Linkin Park Portrait'>
                    </div>
                    <p class='artist-label'>Linkin Park</p>
                </div>
                <div class='col-xs-2 artist-cell'>
                    <div class='overlay rihanna-overlay'>
                        <img class='artist-img' id='rihanna' src='images/rihanna.jpg' alt='Rihanna Portrait'>
                    </div>
                    <p class='artist-label'>Rihanna</p>
                </div>
                <div class='col-xs-2 artist-cell'>
                    <div class='overlay taylor-overlay'>
                        <img class='artist-img' id='taylor' src='images/swift.jpg' alt='Taylor Swift Portrait'>
                    </div>
                    <p class='artist-label'>Taylor Swift</p>
                </div>
                <div class='col-xs-8'>
                    Number of Unique Words Accounted For:
                    <input class='zoom-slider' type="range" min="50" max="1100" value="100" step="1">
                </div>
            </div>
            <script>
                var LYRIC_REGEX = /^[a-z]+$/i;
                var LOCAL_FILEPATH = "data/";
                var artistData;

                d3.queue()
                    .defer(d3.csv, LOCAL_FILEPATH + "coldplaylyrics.csv")
                    .defer(d3.csv, LOCAL_FILEPATH + "kanyewestlyrics.csv")
                    .defer(d3.csv, LOCAL_FILEPATH + "keithurbanlyrics.csv")
                    .defer(d3.csv, LOCAL_FILEPATH + "linkinparklyrics.csv")
                    .defer(d3.csv, LOCAL_FILEPATH + "rihannalyrics.csv")
                    .defer(d3.csv, LOCAL_FILEPATH + "taylorswiftlyrics.csv")
                    .defer(d3.csv, LOCAL_FILEPATH + "pride_parsed.csv")
                    .defer(d3.csv, LOCAL_FILEPATH + "stopwords.csv")
                    .await(function(error, coldplayData, kanyewestData, keithurbanData, linkinparkData, rihannaData, taylorswiftData, prideData, stopwords) {
                    if (error) {
                        console.log("ERROR: " + error)
                    } else {

                        // Read in stopwords and build an array with it
                        var stopwordArr = [];
                        stopwords.forEach(function(w) {
                            if (!(w["words"] == "")) {
                                stopwordArr.push(w["words"])
                            }
                        });

                        var allData = [coldplayData, kanyewestData, keithurbanData, linkinparkData, rihannaData, taylorswiftData]
                        var allArtists = ["Coldplay", "Kanye West", "Keith Urban", "Linkin Park", "Rihanna", "Taylor Swift"]

                        var artistArr = [];

                        for (var i = 0; i < 6; i++) { //6
                            var currentData = allData[i]
                            var artistLyrics = []
                            var artist;
                            currentData.forEach(function(d) {
                                var lower = d.Lyrics.toLowerCase();
                                var split = lower.split(/[\s,?!.:()<>/]+/);
                                split.forEach(function(t) {
                                    if(LYRIC_REGEX.test(t)) {
                                        if (!(stopwordArr.indexOf(t) > -1)) {
                                            artistLyrics.push(t)
                                        }
                                    }
                                });
                            })
                            artistArr.push([allArtists[i], artistLyrics])
                        }

                        var artistFreqArr = [];

                        artistArr.forEach(function(d) { // go through each artist
                            var artist = d[0]
                            var lyrics = d[1]
                            var count = 0;
                            var obj = new Object;
                            lyrics.forEach(function(w) {
                                if (obj[w] == null) {
                                    obj[w] = 1;
                                    count++;
                                } else {
                                    obj[w] += 1;
                                    count++;
                                }
                            });
                            artistFreqArr.push([artist, obj])
                        }); // end of outter

                        sortedArtistList = [];
                        artistFreqArr.forEach(function(d) {
                            var artist = d[0]
                            var list = d[1]
                            var l = []
                            for (var w in list) {
                                l.push([w, list[w]])
                            }
                            var sorted = l.sort(function(a, b) {
                                return b[1] - a[1];
                            });
                            sortedArtistList.push([d[0], sorted]);
                        });

                        artistData = sortedArtistList;

                        var artistShortMapping = {
                            "Coldplay": "coldplay",
                            "Kanye West": "kanye",
                            "Keith Urban": "keith",
                            "Linkin Park": "linkin",
                            "Rihanna": "rihanna",
                            "Taylor Swift": "taylor"
                        };

                        var artistColorMapping = {
                            "Coldplay": "red",
                            "Kanye West": "orange",
                            "Keith Urban": "green",
                            "Linkin Park": "black",
                            "Rihanna": "blue",
                            "Taylor Swift": "pink"
                        };

                        // artistName: group containing line
                        var activeArtists = new Set();
                        var highlightedWord = "none";
                        var selectedScale = "linear"; // 0 -> linear, 1 -> logarithmic

                        // grab svg meta information and reference
                        var artistSvg = d3.select(".artist-svg");
                        var artistSvgWidth = artistSvg.style("width");
                        var artistSvgHeight = artistSvg.style("height");
                        artistSvgHeight = Number(artistSvgHeight.slice(0, artistSvgHeight.length - 2));
                        artistSvgWidth = Number(artistSvgWidth.slice(0, artistSvgWidth.length - 2));

                        // parse data into a dataDictionary for each artist
                        var artistDataDict = {}
                        var maxWordRanks = 1;
                        var maxWordFrequency = 1;
                        for(var artistTuple of artistData) {
                            var artistFullName = artistTuple[0];
                            var sortedLyricArr = artistTuple[1];
                            var artistColor = artistColorMapping[artistFullName];
                            var artistRankCount = sortedLyricArr.length;
                            var artistMostFreqWordCount = sortedLyricArr[0][1];
                            if (artistRankCount > maxWordRanks) {
                                maxWordRanks = artistRankCount;
                            }
                            if (artistMostFreqWordCount > maxWordFrequency) {
                                maxWordFrequency = artistMostFreqWordCount;
                            }
                            artistDataDict[ artistShortMapping[artistFullName] ] = {
                                "fullName": artistFullName,
                                "color": artistColor,
                                "circleGroup": artistSvg.append("g"),
                                "lyricCount": sortedLyricArr
                            };
                        }

                        // grab pride and prejudice svg meta information
                        var prideSvg = d3.select(".pride-svg");
                        var prideSvgWidth = prideSvg.style("width");
                        var prideSvgHeight = prideSvg.style("height");
                        prideSvgHeight = Number(prideSvgHeight.slice(0, prideSvgHeight.length - 2));
                        prideSvgWidth = Number(prideSvgWidth.slice(0, prideSvgWidth.length - 2));
                        var PADDING = 75;

                        // adds text labels to a given svg, returning a reference to the dynamic word label
                        var addLabels = function addSvgPlotLabels(title, yAxisLabel, xAxisLabel, svg) {
                            var svgHeight = Number(svg.style("height").slice(0, svg.style("height").length - 2));
                            var svgWidth = Number(svg.style("width").slice(0, svg.style("width").length - 2));
                            svg.append("text")
                                .attr("transform", "translate(" + (svgWidth/2) + ", 20)")
                                .attr("text-anchor", "middle")
                                .attr("font-size", "20px")
                                .attr("alignment-baseline", "central")
                                .text(title);

                            svg.append("text")
                                .attr("transform", "rotate(270) translate(-" + (svgHeight/2)+ ", 25)")
                                .attr("text-anchor", "middle")
                                .attr("alignment-baseline", "central")
                                .text(yAxisLabel);

                            svg.append("text")
                                .attr("transform", "translate(" + (svgWidth / 2) + ", " + (svgHeight - 25)+ ")")
                                .attr("text-anchor", "middle")
                                .attr("alignment-baseline", "central")
                                .text(xAxisLabel);

                            var wordLabel = svg.append("text")
                                .attr("transform", "translate(0,0)")
                                .attr("text-anchor", "middle")
                                .attr("alignment-baseline", "central")
                                .text("");

                            return wordLabel;
                        }

                        var prideXScale = d3.scaleLinear()
                            .domain([0, 500])
                            .range([PADDING, (prideSvgWidth - PADDING)]);

                        var prideYScale = d3.scaleLinear()
                            .domain([0, prideData[0].count])
                            .range([prideSvgHeight - PADDING, PADDING]);

                        var prideRankAxis = d3.axisBottom(prideXScale);
                        var prideFreqAxis = d3.axisLeft(prideYScale);

                        prideSvg.append("g")
                            .call(prideRankAxis)
                            .attr("transform", "translate(0, " + (prideSvgHeight - PADDING) + ")");

                        prideSvg.append("g")
                            .call(prideFreqAxis)
                            .attr("transform", "translate(" + String(PADDING) + ", 0)");

                        prideData = prideData.slice(0, 500);

                        var baselineData = [];
                        for (var i = 1; i <= 500; i++) {
                            baselineData.push(Math.min((9000/i), 4200));
                        }

                        var pridePathGen = d3.line()
                            .x(function (d, i) { return prideXScale(i) })
                            .y(function (d, i) { return prideYScale(d) });

                        var prideWordLabel = addLabels("Pride and Prejudice Word Usage", "Word Frequency", "Word Count Rank", prideSvg);

                        prideSvg.selectAll("path.baseline")
                            .data([baselineData])
                            .enter()
                            .append("path")
                            .attr("d", function (d) { return pridePathGen(d) })
                            .attr("stroke", "black")
                            .attr("stroke-width", 3)
                            .attr("fill", "none");

                        prideSvg.selectAll("circle")
                            .data(prideData)
                            .enter().append("circle")
                            .attr("cx", function (d, i) { return prideXScale(i+1) })
                            .attr("cy", function (d) { return prideYScale(d.count) })
                            .attr("r", 3)
                            .attr("fill", "grey")
                            .attr("opacity", "0.4")
                            .on('mouseover', function (d, i) {
                                prideWordLabel.text(d.word);
                            })
                            .on('mouseout', function (d, i) {
                                prideWordLabel.text("");
                            });

                        // use only the first numLyricsSliced words
                        var numLyricsSliced = 100;

                        // returns scales for the x-axis
                        var generateScale = function generateXScale() {
                            var linearScale = d3.scaleLinear()
                                .domain([0, numLyricsSliced])
                                .range([PADDING, (artistSvgWidth - PADDING)]);

                            var logScale = d3.scaleLog()
                                .domain([1, numLyricsSliced])
                                .range([PADDING, (artistSvgWidth - PADDING)]);
                            return { linear: linearScale, log: logScale };
                        }

                        var scales = generateScale();
                        // set up scales
                        var linearRankScale = scales.linear;

                        var linearFreqScale = d3.scaleLinear()
                            .domain([0, maxWordFrequency])
                            .range([(artistSvgHeight - PADDING), PADDING]);

                        // instead make this linear as well, but able to change to log if needed
                        var logRankScale = scales.linear;

                        var logFreqScale = d3.scaleLog()
                            .domain([1, maxWordFrequency])
                            .range([(artistSvgHeight - PADDING), PADDING]);

                        // create 4 axes
                        var linearRankAxis = d3.axisBottom(linearRankScale);
                        var linearFreqAxis = d3.axisLeft(linearFreqScale);
                        var logRankAxis = d3.axisBottom(logRankScale);
                        var logFreqAxis = d3.axisLeft(logFreqScale);

                        // contains the 2 axes in a group for linear scales
                        var linearScaleElementGroup = artistSvg.append("g")
                            .attr("class", "linear-scale active");

                        linearScaleElementGroup.append("g")
                            .call(linearRankAxis)
                            .attr("transform", "translate(0, " + (artistSvgHeight - PADDING) + ")")
                            .attr("class", "x-element-axis");

                        linearScaleElementGroup.append("g")
                            .call(linearFreqAxis)
                            .attr("transform", "translate(" + String(PADDING) + ", 0)");

                        // contains the 2 axes in a group for log scales
                        var logScaleElementGroup = artistSvg.append("g")
                            .attr("class", "log-scale");

                        logScaleElementGroup.append("g")
                            .call(logRankAxis)
                            .attr("transform", "translate(0, " + (artistSvgHeight - PADDING) + ")")
                            .attr("class", "x-element-axis");

                        logScaleElementGroup.append("g")
                            .call(logFreqAxis)
                            .attr("transform", "translate(" + PADDING + ", 0)");

                        var musicWordLabel = addLabels("Musician Word Usage", "Word Frequency", "Word Count Rank", artistSvg);

                        // draws circles and a line through the points using the given scales and svg
                        var plotZipfs = function plotZipfsLine(svg, xScale, yScale, artistName, wordLabel) {
                            var artistDict = artistDataDict[artistName];
                            var circleGroup = artistDict.circleGroup;
                            var lyricArr = artistDict.lyricCount.slice(0, numLyricsSliced);
                            var pathGenerator = d3.line()
                                .x(function (d, i) { return xScale(i+1) })
                                .y(function (d, i) { return yScale(d[1]) });

                            var elementGroup = circleGroup.append("g")
                                .attr("class", "element-group");

                            // draw path through points
                            elementGroup.selectAll("path")
                                .data([lyricArr])
                                .enter()
                                .append("path")
                                .attr("d", function (d, i) { return pathGenerator(d) })
                                .attr("stroke", artistDict.color)
                                .attr("fill", "none");

                            // draw circles on each point, adding hover functionality
                            elementGroup.selectAll("circle")
                                .data(lyricArr)
                                .enter().append("circle")
                                .attr("cx", function (d, i) { return xScale(i+1) })
                                .attr("cy", function (d) { return yScale(d[1]) })
                                .attr("r", 4)
                                .attr("fill", artistDict.color)
                                .attr("opacity", "0.4")
                                .on('mouseover', function (d, i) {
                                    wordLabel.text(d[0]);
                                    wordLabel.attr("x", xScale(i)+40)
                                    wordLabel.attr("y", yScale(d[1])-15)
                                    wordLabel.attr("fill", artistDict.color)
                                    wordLabel.attr("pointer-events", "none")
                                })
                                .on('mouseout', function (d, i) {
                                    wordLabel.text("");
                                });
                        }

                        // Draws a large, distinguishing point on an svg for a selected word
                        var displayHighlightedWord = function highlightWord(artistName, xScale, yScale, word, wordLabel) {
                            var artistDict = artistDataDict[artistName];
                            var lyricArr = artistDict.lyricCount;
                            var circleGroup = artistDict.circleGroup;
                            for (var rank in lyricArr.slice(0, numLyricsSliced)) {
                                if (lyricArr[rank][0] === word) {
                                    circleGroup.append("circle")
                                        .attr("cx", xScale(Number(rank) + 1))
                                        .attr("cy", yScale(lyricArr[rank][1]))
                                        .attr("r", 8)
                                        .attr("fill", artistDict.color)
                                        .attr("opacity", "0.9")
                                        .attr("class", "highlight-word")
                                        .on('mouseover', function () {
                                            wordLabel.text(word);
                                            wordLabel.attr("x", xScale(rank)+40)
                                            wordLabel.attr("y", yScale(lyricArr[rank][1])-15)
                                            wordLabel.attr("fill", artistDict.color)
                                            wordLabel.attr("pointer-events", "none")
                                        })
                                        .on('mouseout', function (d, i) {
                                            wordLabel.text("");
                                        });
                                    return;
                                }
                            }
                        }

                        // removed the circle for an artist for an old highlighted word
                        var hideHighlightedWord = function hideWord(artistName) {
                            var circleGroup = artistDataDict[artistName].circleGroup;
                            circleGroup.select(".highlight-word").remove();
                        }

                        // replots all the artists on the music SVG graph
                        var replotArtists = function replotActiveArtists() {
                            activeArtists.forEach(function (artistName) {
                                var artistDict = artistDataDict[artistName];
                                var circleGroup = artistDict.circleGroup;

                                circleGroup.select(".element-group").remove()
                                hideHighlightedWord(artistName);

                                var curXScale = selectedScale === "linear" ? linearRankScale : logRankScale;
                                var curYScale = selectedScale === "linear" ? linearFreqScale : logFreqScale;

                                plotZipfs(artistSvg, curXScale, curYScale, artistName, musicWordLabel);
                                if (highlightedWord !== "none") {
                                    displayHighlightedWord(artistName, curXScale, curYScale, highlightedWord, musicWordLabel);
                                }
                            });
                        }

                        // updates the axes when the user changes the value of the slider and replots them
                        var updateAxes = function updateAxes(numRanks) {
                            numLyricsSliced = numRanks;
                            var scales = generateScale();

                            linearRankScale = scales.linear;
                            logRankScale = scales.linear;

                            linearRankAxis = d3.axisBottom(linearRankScale);
                            logRankAxis = d3.axisBottom(logRankScale);

                            linearScaleElementGroup.select(".x-element-axis").remove();
                            logScaleElementGroup.select(".x-element-axis").remove();

                            linearScaleElementGroup.append("g")
                                .call(linearRankAxis)
                                .attr("transform", "translate(0, " + (artistSvgHeight - PADDING) + ")")
                                .attr("class", "x-element-axis");

                            logScaleElementGroup.append("g")
                                .call(logRankAxis)
                                .attr("transform", "translate(0, " + (artistSvgHeight - PADDING) + ")")
                                .attr("class", "x-element-axis");
                        }

                        // when user clicks an image, toggle the artist on the svg
                        var artistCells = d3.selectAll(".artist-img");
                        artistCells.on('click', function () {
                            var artistName = this.id;
                            if (activeArtists.has(artistName)) {
                                // artist already being displayed -> hide
                                var artistDict = artistDataDict[artistName];
                                var circleGroup = artistDict.circleGroup;
                                circleGroup.select(".element-group").remove();
                                hideHighlightedWord(artistName);
                                activeArtists.delete(artistName);
                            } else {
                                // artist not being displayed -> display
                                var curXScale = selectedScale === "linear" ? linearRankScale : logRankScale;
                                var curYScale = selectedScale === "linear" ? linearFreqScale : logFreqScale;

                                plotZipfs(artistSvg, curXScale, curYScale, artistName, musicWordLabel);
                                if (highlightedWord !== "none") {
                                    displayHighlightedWord(artistName, curXScale, curYScale, highlightedWord, musicWordLabel);
                                }
                                activeArtists.add(artistName);
                            }
                            this.classList.toggle("artist-img-active");
                        });

                        // when the user selects a word, highlight that word on the svg and remove the other instances
                        var wordSelector = d3.select(".word-selector");
                        wordSelector.on('change', function () {
                            var selectedWord = this.value;
                            var curXScale = selectedScale === "linear" ? linearRankScale : logRankScale;
                            var curYScale = selectedScale === "linear" ? linearFreqScale : logFreqScale;
                            highlightedWord = selectedWord;

                            activeArtists.forEach(function (artistName) {
                                hideHighlightedWord(artistName);
                                displayHighlightedWord(artistName, curXScale, curYScale, selectedWord, musicWordLabel);
                            });
                        });

                        // when the user selects a scale, update the graph so it is on the new scale
                        var scaleSelector = d3.select(".scale-selector");
                        scaleSelector.on('change', function () {
                            var pickedScale = this.value;
                            selectedScale = pickedScale;

                            linearScaleElementGroup.classed("active", !linearScaleElementGroup.classed("active"));
                            logScaleElementGroup.classed("active", !linearScaleElementGroup.classed("active"));

                            replotArtists();
                        });

                        // when the user changes the slider, update the x-axis so it changes accordingly
                        var zoomSlider = d3.select(".zoom-slider");
                        zoomSlider.on("input", function () {
                            var numRanks = this.value;
                            updateAxes(numRanks);
                            replotArtists();
                        });

                    }; // end of else
                });
            </script>
        </main>
        <script>
        </script>
    </body>
</html>
